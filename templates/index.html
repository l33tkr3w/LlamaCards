<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LlamaCards</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #ffffff;
            user-select: none;
            overflow: hidden;
        }

        #app {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 200px;
            background-color: #252526;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #main {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            transform-origin: 0 0;
        }

        #connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .card {
            background-color: #333333;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin-bottom: 15px;
            position: absolute;
            width: 225px;
            z-index: 2;
            resize: both;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-bottom: 2px solid #ffffff;
            cursor: grab;
            border-radius: 8px 8px 0 0;
            background-color: #1e1e1e;
        }

        .card-header.llm {
            background-color: #004060;
        }

        .card-header.prompt {
            background-color: #7a3d00;
        }

        .card-header.response-viewer {
            background-color: #5a5a5a;
        }

        .card-header.vision {
            background-color: #006400;
        }

        .card-header.repeater {
            background-color: #8B0000;
        }

        .card-header.embedding {
            background-color: #6a1b9a;
        }

        .card-header.rag {
            background-color: #8b4513;
        }

        .card-title {
            font-weight: bold;
        }

        .card-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
            user-select: text;
        }

        .connection-point {
            width: 0;
            height: 0;
            border-style: solid;
            cursor: pointer;
            position: absolute;
            z-index: 3;
        }

        .input-point {
            border-width: 8px 8px 8px 0;
            border-color: transparent #d9534f transparent transparent;
        }

        .output-point {
            border-width: 8px 0 8px 8px;
            border-color: transparent transparent transparent #007acc;
        }

        .top-input-point {
            top: -4px;
            left: 48%;
            transform: translateX(-50%) rotate(-90deg);
        }

        .top-output-point {
            top: -4px;
            left: 52%;
            transform: translateX(-50%) rotate(-90deg);
        }

        .bottom-input-point {
            bottom: -4px;
            left: 52%;
            transform: translateX(-50%) rotate(90deg);
        }

        .bottom-output-point {
            bottom: -4px;
            left: 48%;
            transform: translateX(-50%) rotate(90deg);
        }

        .left-input-point {
            left: -0px;
            top: 52%;
            transform: translateY(-50%) rotate(180deg);
        }

        .left-output-point {
            left: -0px;
            top: 48%;
            transform: translateY(-50%) rotate(180deg);
        }

        .right-input-point {
            right: -0px;
            top: 48%;
            transform: translateY(-50%) rotate(0deg);
        }

        .right-output-point {
            right: -0px;
            top: 52%;
            transform: translateY(-50%);
        }

        textarea,
        .response-area,
        input,
        select {
            width: 100%;
            background-color: #3c3c3c;
            color: #ffffff;
            border: 1px solid #555;
            box-sizing: border-box;
        }

        .prompt-area {
            height: 37.5px;
        }

        .response-area {
            height: 75px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .response-area pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }

        button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #1177bb;
        }

        .resize-button {
            width: 15px;
            height: 15px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: se-resize;
            background-color: #ffffff;
        }

        .context-menu {
            position: absolute;
            background-color: #3c3c3c;
            border: 1px solid #555;
            padding: 5px 0;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 5px 20px;
            cursor: pointer;
        }

        .context-menu-item:hover {
            background-color: #4c4c4c;
        }

        @keyframes highlight {
            0% {
                box-shadow: 0 0 5px 5px rgba(0, 122, 204, 0.5);
            }

            50% {
                box-shadow: 0 0 15px 15px rgba(0, 122, 204, 0.5);
            }

            100% {
                box-shadow: 0 0 5px 5px rgba(0, 122, 204, 0.5);
            }
        }

        .card.processing {
            animation: highlight 0.75s infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -64;
            }
        }

        .connection {
            stroke: #007acc;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 8, 8;
            animation: dash 1s linear infinite;
        }

        .bottom-controls {
            margin-top: auto;
            padding: 10px;
            border-top: 1px solid #555;
            background-color: #1e1e1e;
            position: relative;
        }

        .layout-list-container {
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            background-color: #2e2e2e;
            max-height: 150px;
            overflow-y: auto;
        }

        .layout-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .layout-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .layout-list-item span {
            flex-grow: 1;
        }

        .layout-list-item button {
            background-color: #d9534f;
            margin-left: 5px;
        }

        .layout-list-item button:hover {
            background-color: #c9302c;
        }

        .footer-text {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #ffffff;
            font-size: 12px;
            z-index: 1000;
        }

        #sidebar-settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            cursor: pointer;
        }

        #settings-popup,
        #endpoint-popup,
        #card-settings-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            padding: 20px;
            border: 1px solid #555;
            z-index: 10000;
        }

        #settings-popup h3,
        #endpoint-popup h3,
        #card-settings-popup h3 {
            margin-top: 0;
        }

        .gear-icon {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-left: auto;
        }

        .default-context-size-container {
            display: flex;
            align-items: center;
        }

        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
            margin-top: 10px;
            max-height: 75px;
            overflow-y: auto;
        }

        .file-list-item {
            background-color: #444;
            padding: 5px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-list-item img {
            max-width: 50px;
            max-height: 50px;
            margin-right: 10px;
        }

        .file-list-item span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 150px;
        }

        .webcam-preview {
            width: 100%;
            height: auto;
            background-color: #222;
            border: 1px solid #555;
            border-radius: 4px;
            margin-top: 10px;
            display: none;
        }

        .webcam-preview video {
            width: 100%;
            height: auto;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="sidebar">
            <div id="sidebar-settings-icon" class="gear-icon" onclick="showSettingsPopup()">⚙</div>
            <h2>LlamaCards</h2>
            <button onclick="clearTable()">Clear Table</button>
            <button onclick="clearCardContent()">Clear Card Content</button>
            <div class="bottom-controls">
                <button onclick="showSaveLayoutPopup()">Save Layout</button>
                <div id="save-layout-popup" style="display: none;">
                    <input type="text" id="layout-name" placeholder="Enter layout name">
                    <button onclick="saveLayout()">Save</button>
                </div>
                <div class="layout-list-container">
                    <ul id="layout-list" class="layout-list"></ul>
                </div>
            </div>
        </div>
        <div id="main">
            <div id="canvas-container">
                <div id="canvas">
                    <svg id="connections"></svg>
                </div>
            </div>
            <div class="footer-text">LlamaCards by Cory Hafer</div>
        </div>
    </div>

    <div id="context-menu" class="context-menu" style="display: none;">
        <div class="context-menu-item" onclick="createCard(event, 'llm')">LLM Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'prompt')">Prompt Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'responseViewer')">Viewer Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'vision')">Vision Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'repeater')">Repeater Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'embedding')">Embedding Card</div>
        <div class="context-menu-item" onclick="createCard(event, 'rag')">RAG Card</div>
    </div>

    <div id="settings-popup">
        <h3>Settings</h3>
        <label for="default-model-select">Default Model:</label>
        <select id="default-model-select" onchange="saveDefaultModel()"></select>
        <br>
        <hr>
        <label for="default-context-size-slider">Default Context Size:</label>
        <input type="range" id="default-context-size-slider" min="2048" max="131072" step="1024" value="2048"
            oninput="updateContextSizeDisplay(this.value)">
        <span id="context-size-display">2048</span>
        <br>
        <hr>
        <label for="enable-default-context-size"> Enable Default Context Size</label>
        <input type="checkbox" id="enable-default-context-size" onchange="saveDefaultContextSize()">
        <br>
        <hr>
        <label for="endpoint-input">Ollama Endpoint:</label>
        <input type="text" id="endpoint-input" value="http://localhost:5000">
        <br>
        <button onclick="saveSettings()">Save</button>
        <button onclick="closeSettingsPopup()">Cancel</button>
    </div>

    <div id="card-settings-popup">
        <h3>Card Settings</h3>
        <label for="context-size-slider">Context Size:</label>
        <input type="range" id="context-size-slider" min="2048" max="131072" step="1024" value="2048"
            oninput="updateCardContextSizeDisplay(this.value)">
        <span id="card-context-size-display">2048</span>
        <br>
        <button onclick="saveCardSettings()">Save</button>
        <button onclick="closeCardSettingsPopup()">Cancel</button>
    </div>

    <script>
        let cards = [];
        let connections = [];
        let draggedPoint = null;
        let zoom = 1;
        let isPanning = false;
        let startX, startY, offsetX = 0,
            offsetY = 0;
        const connectionsSVG = document.getElementById('connections');
        const main = document.getElementById('main');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const contextMenu = document.getElementById('context-menu');
        let currentSettingsCard = null;
        let ollamaEndpoint = getCookie('ollamaEndpoint') || 'http://localhost:5000';
        let modelList = [];
        let defaultModel = getCookie('defaultModel') || '';
        let defaultContextSize = getCookie('defaultContextSize') || 2048;
        let enableDefaultContextSize = getCookie('enableDefaultContextSize') === 'true';
        let webcamStream = null;
        let repeaterIntervals = {};

        async function fetchModels() {
            try {
                const response = await fetch('/api/models');
                if (response.ok) {
                    modelList = await response.json();
                    defaultModel = defaultModel || modelList[0]; // Default to the first model in the list
                    updateModelDropdowns();
                    updateDefaultModelDropdown();
                } else {
                    console.error('Failed to fetch models');
                }
            } catch (error) {
                console.error('Error fetching models:', error);
            }
        }

        function updateModelDropdowns() {
            const selects = document.querySelectorAll('select[id^="modelSelect"]');
            selects.forEach(select => {
                const currentModel = select.value;
                select.innerHTML = '';
                modelList.forEach(model => {
                    if (model !== 'NAME') {
                        const option = document.createElement('option');
                        option.value = model;
                        option.text = model;
                        if (model === currentModel || model === defaultModel) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                });
            });
        }

        function updateDefaultModelDropdown() {
            const defaultModelSelect = document.getElementById('default-model-select');
            defaultModelSelect.innerHTML = '';
            modelList.forEach(model => {
                if (model !== 'NAME') {
                    const option = document.createElement('option');
                    option.value = model;
                    option.text = model;
                    if (model === defaultModel) {
                        option.selected = true;
                    }
                    defaultModelSelect.appendChild(option);
                }
            });
        }

        function saveDefaultModel() {
            const defaultModelSelect = document.getElementById('default-model-select');
            defaultModel = defaultModelSelect.value;
            setCookie('defaultModel', defaultModel, 365);
            updateModelDropdowns();
        }

        function saveDefaultContextSize() {
            const enableDefaultContextSizeCheckbox = document.getElementById('enable-default-context-size');
            enableDefaultContextSize = enableDefaultContextSizeCheckbox.checked;
            setCookie('enableDefaultContextSize', enableDefaultContextSize, 365);

            const defaultContextSizeSlider = document.getElementById('default-context-size-slider');
            defaultContextSize = defaultContextSizeSlider.value;
            setCookie('defaultContextSize', defaultContextSize, 365);
        }

        function createCard(event, type) {
            const card = document.createElement('div');
            card.className = 'card';
            const canvasRect = canvas.getBoundingClientRect();
            card.style.left = `${(event.clientX - canvasRect.left) / zoom}px`;
            card.style.top = `${(event.clientY - canvasRect.top) / zoom}px`;
            card.dataset.inputsReceived = 0;
            card.dataset.expectedInputs = 0;
            card.dataset.responses = '';
            card.dataset.cardId = `card-${Date.now()}`;
            let cardContent = '';

            switch (type) {
                case 'llm':
                    card.dataset.model = defaultModel || (modelList[0] && modelList[0] !== 'NAME' ? modelList[0] : '');
                    card.dataset.prompt = '';
                    card.dataset.message = '';
                    card.dataset.contextSize = enableDefaultContextSize ? defaultContextSize : 2048; // Default context size
                    cardContent = `
                        <div class="card-header llm" onmousedown="startDragCard(event, this)">
                            <span class="card-title">LLM Card ${cards.length + 1}</span>
                            <div class="gear-icon" onclick="showCardSettingsPopup(this.parentNode.parentNode)">⚙</div>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <label for="modelSelect${cards.length}">Model</label>
                            <select id="modelSelect${cards.length}" onchange="updateCardModel(this)">
                                ${modelList.map(model => model !== 'NAME' ? `<option value="${model}" ${model === card.dataset.model ? 'selected' : ''}>${model}</option>` : '').join('')}
                            </select>
                            <textarea class="prompt-area" placeholder="Enter prompt" onchange="updateCardPrompt(this)"></textarea>
                            <textarea class="message-area" placeholder="Enter your message"></textarea>
                            <button onclick="sendMessage(this.parentNode.parentNode)">Send</button>
                            <div class="response-area"></div>
                        </div>`;
                    break;
                case 'prompt':
                    cardContent = `
                        <div class="card-header prompt" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Prompt Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <textarea class="prompt-input" placeholder="Enter prompt"></textarea>
                            <textarea class="message-input" placeholder="Enter your message"></textarea>
                            <button onclick="sendPrompt(this.parentNode.parentNode)">Send</button>
                        </div>`;
                    break;
                case 'responseViewer':
                    cardContent = `
                        <div class="card-header response-viewer" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Viewer Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <div class="response-area"></div>
                            <label for="sendAfterResponses${cards.length}">Send after</label>
                            <input type="number" id="sendAfterResponses${cards.length}" min="1" value="1" style="width: 50px;">
                            <span>responses</span>
                            <button onclick="sendResponseDownstream(this.parentNode.parentNode)">Send Response</button>
                        </div>`;
                    break;
                case 'vision':
                    card.dataset.mode = 'image';
                    cardContent = `
                        <div class="card-header vision" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Vision Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <label for="visionMode${cards.length}">Mode:</label>
                            <select id="visionMode${cards.length}" onchange="updateVisionMode(this)">
                                <option value="image">Image</option>
                                <option value="webcam">Webcam</option>
                            </select>
                            <div class="vision-input">
                                <input type="file" id="visionFile${cards.length}" multiple onchange="displaySelectedFiles(this)">
                                <ul class="file-list" id="fileList${cards.length}"></ul>
                            </div>
                            <div class="webcam-preview" id="webcamPreview${cards.length}">
                                <video id="webcamVideo${cards.length}" autoplay></video>
                                <label for="snapshotTimer${cards.length}">Snapshot Timer (ms):</label>
                                <input type="range" id="snapshotTimer${cards.length}" min="100" max="10000" step="100" value="1000"
                                    oninput="updateSnapshotTimerDisplay(this)">
                                <span id="snapshotTimerDisplay${cards.length}">1000</span>
                                <label for="repeatToggle${cards.length}">Repeat:</label>
                                <input type="checkbox" id="repeatToggle${cards.length}">
                            </div>
                            <button onclick="sendVisionData(this.parentNode.parentNode)">Send</button>
                        </div>`;
                    break;
                case 'repeater':
                    cardContent = `
                        <div class="card-header repeater" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Repeater Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <label for="repeaterTimer${cards.length}">Timer (ms):</label>
                            <input type="range" id="repeaterTimer${cards.length}" min="100" max="10000" step="100" value="1000"
                                oninput="updateRepeaterTimerDisplay(this)">
                            <span id="repeaterTimerDisplay${cards.length}">1000</span>
                            <textarea class="prompt-area" placeholder="Enter prompt"></textarea>
                            <textarea class="message-area" placeholder="Enter your message"></textarea>
                            <button onclick="toggleRepeater(this.parentNode.parentNode)">Start</button>
                        </div>`;
                    break;
                case 'embedding':
                    cardContent = `
                        <div class="card-header embedding" onmousedown="startDragCard(event, this)">
                            <span class="card-title">Embedding Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <input type="text" class="table-name-input" placeholder="Enter table name">
                            <textarea class="text-input" placeholder="Enter text to embed"></textarea>
                            <button onclick="embedText(this.parentNode.parentNode)">Embed</button>
                            <div class="response-area"></div>
                        </div>`;
                    break;
                case 'rag':
                    cardContent = `
                        <div class="card-header rag" onmousedown="startDragCard(event, this)">
                            <span class="card-title">RAG Card ${cards.length + 1}</span>
                            <button onclick="removeCard(this.parentNode.parentNode)">X</button>
                        </div>
                        <div class="card-body">
                            <textarea class="prompt-input" placeholder="Enter prompt"></textarea>
                            <select class="table-select"></select>
                            <button onclick="sendRAGRequest(this.parentNode.parentNode)">Send</button>
                            <div class="response-area"></div>
                        </div>`;
                    break;
            }

            card.innerHTML = cardContent;
            card.innerHTML += `
                <div class="connection-point input-point top-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point top-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point bottom-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point bottom-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point left-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point left-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point input-point right-input-point" onmousedown="startDrag(event, 'input')" ondblclick="disconnectDot(event, this)"></div>
                <div class="connection-point output-point right-output-point" onmousedown="startDrag(event, 'output')" ondblclick="disconnectDot(event, this)"></div>
                <div class="resize-button" onmousedown="startResize(event, this)"></div>`;
            canvas.appendChild(card);
            cards.push(card);
            updateExpectedInputs();
            hideContextMenu();

            if (type === 'rag') {
                loadTablesForRAGCard(card);
            }
        }

        async function loadTablesForRAGCard(card) {
            const tableSelect = card.querySelector('.table-select');
            try {
                const response = await fetch('/api/tables');
                if (response.ok) {
                    const tables = await response.json();
                    tables.forEach(table => {
                        const option = document.createElement('option');
                        option.value = table;
                        option.text = table;
                        tableSelect.appendChild(option);
                    });
                } else {
                    console.error('Failed to fetch tables');
                }
            } catch (error) {
                console.error('Error fetching tables:', error);
            }
        }

        async function sendRAGRequest(card) {
            const promptInput = card.querySelector('.prompt-input').value.trim();
            const tableSelect = card.querySelector('.table-select').value;
            const responseArea = card.querySelector('.response-area');

            if (promptInput && tableSelect) {
                try {
                    const response = await fetch('/api/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            prompt: promptInput,
                            table_name: tableSelect,
                        }),
                    });

                    if (response.ok) {
                        const data = await response.json();
                        responseArea.innerHTML = `<pre>${data.response}</pre>`;
                    } else {
                        throw new Error('Failed to generate response');
                    }
                } catch (error) {
                    console.error('Error:', error);
                    responseArea.innerHTML = `<pre>Error: ${error.message}</pre>`;
                }
            } else {
                responseArea.innerHTML = `<pre>Error: Prompt and table selection are required</pre>`;
            }
        }

        function clearTable() {
            cards.forEach(card => removeCard(card));
            cards = [];
            connections = [];
            connectionsSVG.innerHTML = '';
        }

        function clearCardContent() {
            cards.forEach(card => {
                const responseArea = card.querySelector('.response-area');
                if (responseArea) {
                    responseArea.innerHTML = '';
                }
            });
        }

        function updateExpectedInputs() {
            cards.forEach(card => {
                card.dataset.expectedInputs = connections.filter(conn => conn.to.closest('.card') === card).length;
            });
        }

        function updateCardModel(select) {
            const card = select.closest('.card');
            card.dataset.model = select.value;
        }

        function updateCardPrompt(textarea) {
            const card = textarea.closest('.card');
            card.dataset.prompt = textarea.value;
        }

        function removeCard(card) {
            clearInterval(repeaterIntervals[card.dataset.cardId]);
            delete repeaterIntervals[card.dataset.cardId];
            connections = connections.filter(conn => conn.from.closest('.card') !== card && conn.to.closest('.card') !== card);
            cards = cards.filter(c => c !== card);
            card.remove();
            updateExpectedInputs();
            drawConnections();
        }

        function startDragCard(event, header) {
            event.stopPropagation();
            const card = header.parentElement;
            isDraggingCard = true;
            currentDraggedCard = card;
            startX = event.clientX - card.offsetLeft * zoom;
            startY = event.clientY - card.offsetTop * zoom;

            document.addEventListener('mousemove', dragCard);
            document.addEventListener('mouseup', stopDragCard);
        }

        function dragCard(event) {
            if (!isDraggingCard) return;
            const newX = (event.clientX - startX) / zoom;
            const newY = (event.clientY - startY) / zoom;
            currentDraggedCard.style.left = `${newX}px`;
            currentDraggedCard.style.top = `${newY}px`;
            drawConnections();
        }

        function stopDragCard() {
            isDraggingCard = false;
            currentDraggedCard = null;
            document.removeEventListener('mousemove', dragCard);
            document.removeEventListener('mouseup', stopDragCard);
        }

        function startDrag(event, type) {
            event.stopPropagation();
            event.preventDefault();
            draggedPoint = {
                element: event.target,
                type: type
            };
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }

        function drag(event) {
            if (!draggedPoint) return;
            drawConnections(event.clientX, event.clientY);
        }

        function stopDrag(event) {
            if (!draggedPoint) return;
            const targetPoint = findTargetPoint(event);
            if (targetPoint && targetPoint.type === 'input' && draggedPoint.type === 'output') {
                const connection = {
                    from: draggedPoint.element,
                    to: targetPoint.element
                };
                connections.push(connection);
                updateExpectedInputs();
            }
            draggedPoint = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            drawConnections();
        }

        function disconnectDot(event, element) {
            event.stopPropagation();
            connections = connections.filter(conn => conn.from !== element && conn.to !== element);
            updateExpectedInputs();
            drawConnections();
        }

        function findTargetPoint(event) {
            const points = document.querySelectorAll('.connection-point');
            for (const point of points) {
                const rect = point.getBoundingClientRect();
                if (event.clientX >= rect.left && event.clientX <= rect.right &&
                    event.clientY >= rect.top && event.clientY <= rect.bottom) {
                    return {
                        element: point,
                        type: point.classList.contains('input-point') ? 'input' : 'output'
                    };
                }
            }
            return null;
        }

        function drawConnections(tempX, tempY) {
            connectionsSVG.innerHTML = '';

            for (const conn of connections) {
                const fromRect = conn.from.getBoundingClientRect();
                const toRect = conn.to.getBoundingClientRect();
                const startX = (fromRect.left + fromRect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const startY = (fromRect.top + fromRect.height / 2 - canvas.getBoundingClientRect().top) / zoom;
                const endX = (toRect.left + toRect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const endY = (toRect.top + toRect.height / 2 - canvas.getBoundingClientRect().top) / zoom;

                drawBezierCurve(startX, startY, endX, endY);
            }

            if (draggedPoint && tempX !== undefined && tempY !== undefined) {
                const rect = draggedPoint.element.getBoundingClientRect();
                const startX = (rect.left + rect.width / 2 - canvas.getBoundingClientRect().left) / zoom;
                const startY = (rect.top + rect.height / 2 - canvas.getBoundingClientRect().top) / zoom;
                drawBezierCurve(startX, startY, (tempX - canvas.getBoundingClientRect().left) / zoom, (tempY - canvas.getBoundingClientRect().top) / zoom);
            }
        }

        function drawBezierCurve(startX, startY, endX, endY) {
            const controlPoint1X = startX + (endX - startX) / 3;
            const controlPoint1Y = startY;
            const controlPoint2X = startX + 2 * (endX - startX) / 3;
            const controlPoint2Y = endY;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${startX},${startY} C${controlPoint1X},${controlPoint1Y} ${controlPoint2X},${controlPoint2Y} ${endX},${endY}`);
            path.setAttribute('class', 'connection');
            connectionsSVG.appendChild(path);
        }

        async function sendMessage(card) {
            const textarea = card.querySelector('.message-area');
            if (textarea) {
                const message = textarea.value.trim();
                if (message) {
                    await processCardMessage(card, message);
                    textarea.value = ''; // Comment this line if you don't want to clear the input field
                }
            }
        }

        async function processCardMessage(card, message, images = []) {
            const model = card.dataset.model || '';
            const prompt = card.dataset.prompt || '';
            const contextSize = enableDefaultContextSize ? defaultContextSize : (card.dataset.contextSize || 2048);
            let combinedInput = `${prompt}${message}`;
            if (!combinedInput) combinedInput = "what is in this image?";

            card.classList.add('processing');
            try {
                let finalResponse;
                const cardHeader = card.querySelector('.card-header');

                if (cardHeader && cardHeader.classList.contains('llm')) {
                    const response = await queryOllama(model, combinedInput, contextSize, images);
                    finalResponse = extractMessageContent(response);
                    if (finalResponse) {
                        appendResponse(card, finalResponse);
                    }
                } else if (cardHeader && cardHeader.classList.contains('response-viewer')) {
                    finalResponse = message;
                    appendResponse(card, finalResponse);
                } else if (cardHeader && cardHeader.classList.contains('embedding')) {
                    finalResponse = message;
                    appendResponse(card, finalResponse);
                    await embedResponseInCard(card, finalResponse);
                }

                card.classList.remove('processing');

                const connectedCards = connections
                    .filter(conn => conn.from.closest('.card') === card)
                    .map(conn => conn.to.closest('.card'));

                if (connectedCards.length > 0) {
                    await Promise.all(
                        connectedCards.map(async (nextCard) => {
                            nextCard.dataset.inputsReceived++;
                            nextCard.dataset.responses += finalResponse + '\n';

                            if (parseInt(nextCard.dataset.inputsReceived, 10) >= nextCard.dataset.expectedInputs) {
                                const combinedResponse = nextCard.dataset.responses.trim();
                                nextCard.dataset.responses = '';
                                nextCard.dataset.inputsReceived = 0;
                                await processCardMessage(nextCard, combinedResponse, images);
                            }
                        })
                    );
                }
            } catch (error) {
                console.error('Error processing message:', error);
                appendResponse(card, `Error: Unable to process message. Error details: ${error.message}`);
                card.classList.remove('processing');
            }
        }

        async function embedResponseInCard(embeddingCard, responseText) {
            const tableNameInput = embeddingCard.querySelector('.table-name-input');
            const responseArea = embeddingCard.querySelector('.response-area');

            const tableName = tableNameInput.value.trim();

            if (tableName && responseText) {
                embeddingCard.classList.add('processing'); // Start animation
                try {
                    const response = await fetch('/api/embed', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ table_name: tableName, text: responseText }),
                    });

                    if (response.ok) {
                        const responseData = await response.json();
                        responseArea.innerHTML = `<pre>${responseData.message}</pre>`;
                    } else {
                        throw new Error('Failed to embed response');
                    }
                } catch (error) {
                    console.error('Error embedding response:', error);
                    responseArea.innerHTML = `<pre>Error: ${error.message}</pre>`;
                } finally {
                    embeddingCard.classList.remove('processing'); // End animation
                }
            } else {
                responseArea.innerHTML = `<pre>Error: Table name cannot be empty</pre>`;
            }
        }

        async function queryOllama(model, input, contextSize, images = []) {
            const payload = {
                model: model,
                messages: [{
                    role: 'user',
                    content: input,
                    images: images
                }],
                stream: false,
                context_size: contextSize,
                endpoint: ollamaEndpoint
            };
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                throw new Error('Failed to get response from Ollama');
            }

            const responseData = await response.json();
            return JSON.stringify(responseData);
        }

        function appendResponse(card, response) {
            const outputArea = card.querySelector('.response-area');
            if (outputArea) {
                const existingContent = outputArea.innerHTML;
                outputArea.innerHTML = existingContent + `<pre>${response}</pre>`;
                outputArea.scrollTop = outputArea.scrollHeight;
            }
        }

        function extractMessageContent(response) {
            try {
                const parsedResponse = JSON.parse(response);
                if (parsedResponse.message && parsedResponse.message.content) {
                    return parsedResponse.message.content;
                }
            } catch (error) {
                console.error('Error parsing JSON:', error);
            }
            return null;
        }

        function sendPrompt(card) {
            const promptInput = card.querySelector('.prompt-input');
            const messageInput = card.querySelector('.message-input');
            if (promptInput && messageInput) {
                const prompt = promptInput.value.trim();
                const message = messageInput.value.trim();
                if (prompt || message) {
                    forwardPrompt(card, prompt, message);
                }
            }
        }

        function forwardPrompt(card, prompt, message) {
            const connectedCards = connections
                .filter(conn => conn.from.closest('.card') === card)
                .map(conn => conn.to.closest('.card'));

            connectedCards.forEach(nextCard => {
                if (prompt) {
                    nextCard.dataset.prompt = prompt;
                    const promptArea = nextCard.querySelector('.prompt-area');
                    if (promptArea) {
                        promptArea.value = prompt;
                    }
                }
                if (message) {
                    nextCard.dataset.message = message;
                    const messageArea = nextCard.querySelector('.message-area');
                    if (messageArea) {
                        messageArea.value = message;
                    }
                }
                sendMessage(nextCard);
            });
        }

        function updateVisionMode(select) {
            const card = select.closest('.card');
            const visionInput = card.querySelector('.vision-input');
            const webcamPreview = card.querySelector('.webcam-preview');

            if (select.value === 'image') {
                visionInput.style.display = 'block';
                webcamPreview.style.display = 'none';
                if (webcamStream) {
                    const video = webcamPreview.querySelector('video');
                    video.srcObject = null;
                    webcamStream.getTracks().forEach(track => track.stop());
                    webcamStream = null;
                }
            } else {
                visionInput.style.display = 'none';
                webcamPreview.style.display = 'block';
                startWebcam(card);
            }
        }

        function displaySelectedFiles(input) {
            const fileList = input.nextElementSibling;
            fileList.innerHTML = '';

            Array.from(input.files).forEach(file => {
                const listItem = document.createElement('li');
                listItem.className = 'file-list-item';
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                listItem.appendChild(img);
                const span = document.createElement('span');
                span.textContent = file.name;
                listItem.appendChild(span);
                fileList.appendChild(listItem);
            });
        }

        function startWebcam(card) {
            const webcamPreview = card.querySelector('.webcam-preview');
            const video = webcamPreview.querySelector('video');
            const timerInput = webcamPreview.querySelector('input[type="range"]');
            const repeatToggle = webcamPreview.querySelector('input[type="checkbox"]');

            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    webcamStream = stream;
                    video.srcObject = stream;
                })
                .catch(error => {
                    console.error('Error accessing webcam:', error);
                });

            repeatToggle.addEventListener('change', () => {
                if (repeatToggle.checked) {
                    startSnapshotTimer(card, parseInt(timerInput.value, 10));
                } else {
                    stopSnapshotTimer(card);
                }
            });
        }

        function takeSnapshot(card) {
            const video = card.querySelector('video');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/png').replace(/^data:image\/(png|jpeg);base64,/, '');

            const connectedCards = connections.filter(conn => conn.from.closest('.card') === card);
            if (connectedCards.length > 0) {
                forwardVisionData(card, dataUrl);
            }
        }

        function startSnapshotTimer(card, interval) {
            const cardId = card.dataset.cardId;

            if (repeaterIntervals[cardId]) {
                clearInterval(repeaterIntervals[cardId]);
            }

            repeaterIntervals[cardId] = setInterval(() => {
                takeSnapshot(card);
            }, interval);

            const timerInput = card.querySelector('.webcam-preview input[type="range"]');
            timerInput.addEventListener('input', () => {
                clearInterval(repeaterIntervals[cardId]);
                repeaterIntervals[cardId] = setInterval(() => {
                    takeSnapshot(card);
                }, parseInt(timerInput.value, 10));
            });
        }

        function stopSnapshotTimer(card) {
            const cardId = card.dataset.cardId;
            if (repeaterIntervals[cardId]) {
                clearInterval(repeaterIntervals[cardId]);
                delete repeaterIntervals[cardId];
            }
        }

        async function sendVisionData(card) {
            const visionModeSelect = card.querySelector('select');
            if (visionModeSelect) {
                const visionMode = visionModeSelect.value;
                if (visionMode === 'image') {
                    const fileInput = card.querySelector('input[type="file"]');
                    if (fileInput && fileInput.files) {
                        for (const file of fileInput.files) {
                            const dataUrl = await readFileAsDataUrl(file);
                            await processCardMessageSequentially(card, "", [dataUrl]);
                        }
                    }
                } else if (visionMode === 'webcam') {
                    takeSnapshot(card);
                }
            }
        }

        async function processCardMessageSequentially(card, message, images = []) {
            const model = card.dataset.model || '';
            const prompt = card.dataset.prompt || '';
            const contextSize = enableDefaultContextSize ? defaultContextSize : (card.dataset.contextSize || 2048);
            let combinedInput = `${prompt}${message}`;
            if (!combinedInput) combinedInput = "what is in this image?";

            card.classList.add('processing');
            try {
                let finalResponse;
                const cardHeader = card.querySelector('.card-header');
                if (cardHeader && cardHeader.classList.contains('llm')) {
                    const response = await queryOllama(model, combinedInput, contextSize, images);
                    finalResponse = extractMessageContent(response);
                    if (finalResponse) {
                        appendResponse(card, finalResponse);
                    }
                } else if (cardHeader && cardHeader.classList.contains('response-viewer')) {
                    finalResponse = message;
                    appendResponse(card, finalResponse);
                } else if (cardHeader && cardHeader.classList.contains('embedding')) {
                    finalResponse = message;
                    appendResponse(card, finalResponse);
                    await embedResponseInCard(card, finalResponse);
                }
                card.classList.remove('processing');

                const connectedCards = connections
                    .filter(conn => conn.from.closest('.card') === card)
                    .map(conn => conn.to.closest('.card'));

                for (const nextCard of connectedCards) {
                    nextCard.dataset.inputsReceived++;
                    nextCard.dataset.responses += finalResponse + '\n';
                    if (parseInt(nextCard.dataset.inputsReceived, 10) >= nextCard.dataset.expectedInputs) {
                        const combinedResponse = nextCard.dataset.responses.trim();
                        nextCard.dataset.responses = '';
                        nextCard.dataset.inputsReceived = 0;
                        await processCardMessageSequentially(nextCard, combinedResponse, images);
                    }
                }
            } catch (error) {
                console.error('Error processing message:', error);
                appendResponse(card, `Error: Unable to process message. Error details: ${error.message}`);
                card.classList.remove('processing');
            }
        }

        function readFileAsDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.replace(/^data:image\/(png|jpeg);base64,/, ''));
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function forwardVisionData(card, dataUrl) {
            const connectedCards = connections
                .filter(conn => conn.from.closest('.card') === card)
                .map(conn => conn.to.closest('.card'));

            connectedCards.forEach(nextCard => {
                nextCard.dataset.imagePath = dataUrl;
                processCardMessage(nextCard, "", [dataUrl]);
            });
        }

        function toggleRepeater(card) {
            const timerInput = card.querySelector('input[type="range"]');
            const promptArea = card.querySelector('.prompt-area');
            const messageArea = card.querySelector('.message-area');
            const button = card.querySelector('button');
            const interval = parseInt(timerInput.value, 10);
            const cardId = card.dataset.cardId;

            if (repeaterIntervals[cardId]) {
                clearInterval(repeaterIntervals[cardId]);
                delete repeaterIntervals[cardId];
                button.textContent = 'Start';
            } else {
                repeaterIntervals[cardId] = setInterval(() => {
                    const prompt = promptArea.value.trim();
                    const message = messageArea.value.trim();
                    processCardMessage(card, `${prompt}${message}`);
                }, interval);
                button.textContent = 'Stop';
            }
        }

        function updateSnapshotTimerDisplay(rangeInput) {
            const displaySpan = rangeInput.nextElementSibling;
            displaySpan.textContent = rangeInput.value;
        }

        function updateRepeaterTimerDisplay(rangeInput) {
            const displaySpan = rangeInput.nextElementSibling;
            displaySpan.textContent = rangeInput.value;
        }

        function zoomIn() {
            zoom *= 1.1;
            applyZoom();
        }

        function zoomOut() {
            zoom /= 1.1;
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoom})`;
            drawConnections();
        }

        function showContextMenu(event) {
            event.preventDefault();
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
        }

        function startResize(event, resizeButton) {
            event.stopPropagation();
            const card = resizeButton.closest('.card');
            const startWidth = card.offsetWidth;
            const startHeight = card.offsetHeight;
            const startX = event.clientX;
            const startY = event.clientY;

            function resize(event) {
                const newWidth = startWidth + (event.clientX - startX);
                const newHeight = startHeight + (event.clientY - startY);
                card.style.width = `${newWidth}px`;
                card.style.height = `${newHeight}px`;

                const responseArea = card.querySelector('.response-area');
                if (responseArea) {
                    responseArea.style.height = `${newHeight - 112.5}px`;
                }

                drawConnections();
            }

            function stopResize() {
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
            }

            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function showCardSettingsPopup(card) {
            currentSettingsCard = card;
            const contextSize = card.dataset.contextSize || 2048;
            document.getElementById('context-size-slider').value = contextSize;
            document.getElementById('card-context-size-display').innerText = contextSize;
            document.getElementById('card-settings-popup').style.display = 'block';
        }

        function showSettingsPopup() {
            document.getElementById('default-model-select').value = defaultModel;
            document.getElementById('default-context-size-slider').value = defaultContextSize;
            document.getElementById('context-size-display').innerText = defaultContextSize;
            document.getElementById('enable-default-context-size').checked = enableDefaultContextSize;
            document.getElementById('endpoint-input').value = ollamaEndpoint;
            document.getElementById('settings-popup').style.display = 'block';
        }

        function closeSettingsPopup() {
            document.getElementById('settings-popup').style.display = 'none';
            currentSettingsCard = null;
        }

        function closeCardSettingsPopup() {
            document.getElementById('card-settings-popup').style.display = 'none';
            currentSettingsCard = null;
        }

        async function saveSettings() {
            saveDefaultModel();
            saveDefaultContextSize();
            await saveEndpoint();
            closeSettingsPopup();
        }

        function saveCardSettings() {
            if (currentSettingsCard) {
                const contextSize = document.getElementById('context-size-slider').value;
                currentSettingsCard.dataset.contextSize = contextSize;
            }
            closeCardSettingsPopup();
        }

        function updateContextSizeDisplay(value) {
            document.getElementById('context-size-display').innerText = value;
        }

        function updateCardContextSizeDisplay(value) {
            document.getElementById('card-context-size-display').innerText = value;
        }

        async function saveEndpoint() {
            const newEndpoint = document.getElementById('endpoint-input').value.trim();
            if (newEndpoint) {
                ollamaEndpoint = newEndpoint;
                setCookie('ollamaEndpoint', ollamaEndpoint, 365);
                try {
                    const response = await fetch('/api/update-endpoint', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ endpoint: ollamaEndpoint }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to update endpoint on server');
                    }
                } catch (error) {
                    console.error('Error updating endpoint on server:', error);
                }
                fetchModels();
                closeEndpointPopup();
            }
        }

        function initialize() {
            window.addEventListener('resize', () => {
                drawConnections();
            });
            main.addEventListener('contextmenu', showContextMenu);
            document.addEventListener('click', hideContextMenu);

            canvasContainer.addEventListener('mousedown', (e) => {
                if (e.target.closest('.card')) return;
                isPanning = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
                canvasContainer.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoom})`;
                drawConnections();
            });

            document.addEventListener('mouseup', () => {
                isPanning = false;
                canvasContainer.style.cursor = 'grab';
            });

            canvasContainer.addEventListener('wheel', (e) => {
                if (e.target.closest('.card')) {
                    e.stopPropagation();
                } else {
                    const mouseX = (e.clientX - canvas.getBoundingClientRect().left) / zoom;
                    const mouseY = (e.clientY - canvas.getBoundingClientRect().top) / zoom;
                    if (e.deltaY < 0) {
                        zoomIn();
                    } else {
                        zoomOut();
                    }
                    offsetX = 0;
                    offsetY = 0;
                    applyZoom();
                }
            });

            loadLayoutsFromCookies();
            drawConnections();
            fetchModels();
        }

        function showSaveLayoutPopup() {
            document.getElementById('save-layout-popup').style.display = 'block';
        }

        function saveLayout() {
            const layoutName = document.getElementById('layout-name').value.trim();
            if (!layoutName) return;

            const layoutData = {
                cards: cards.map(card => ({
                    type: card.querySelector('.card-header').classList.contains('llm') ? 'llm' :
                        card.querySelector('.card-header').classList.contains('prompt') ? 'prompt' :
                            card.querySelector('.card-header').classList.contains('response-viewer') ? 'responseViewer' :
                                card.querySelector('.card-header').classList.contains('vision') ? 'vision' :
                                    card.querySelector('.card-header').classList.contains('embedding') ? 'embedding' :
                                        card.querySelector('.card-header').classList.contains('rag') ? 'rag' :
                                            'repeater',
                    left: card.style.left,
                    top: card.style.top,
                    model: card.dataset.model || '',
                    prompt: card.dataset.prompt || '',
                    message: card.querySelector('.message-area') ? card.querySelector('.message-area').value : ''
                })),
                connections: connections.map(conn => ({
                    from: {
                        cardIndex: cards.indexOf(conn.from.closest('.card')),
                        pointClass: Array.from(conn.from.classList).find(cls => cls.includes('-point'))
                    },
                    to: {
                        cardIndex: cards.indexOf(conn.to.closest('.card')),
                        pointClass: Array.from(conn.to.classList).find(cls => cls.includes('-point'))
                    }
                }))
            };

            setCookie(`layout_${layoutName}`, JSON.stringify(layoutData), 365);
            document.getElementById('save-layout-popup').style.display = 'none';
            loadLayoutsFromCookies();
        }

        function loadLayoutsFromCookies() {
            const layoutList = document.getElementById('layout-list');
            layoutList.innerHTML = '';

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('layout_')) {
                    const layoutName = key.slice('layout_'.length);
                    const listItem = document.createElement('li');
                    listItem.className = 'layout-list-item';

                    const span = document.createElement('span');
                    span.textContent = layoutName;
                    listItem.appendChild(span);

                    const loadButton = document.createElement('button');
                    loadButton.textContent = 'Load';
                    loadButton.onclick = () => loadLayout(layoutName);
                    listItem.appendChild(loadButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.onclick = () => deleteLayout(layoutName);
                    listItem.appendChild(deleteButton);

                    layoutList.appendChild(listItem);
                }
            }
        }

        function loadLayout(layoutName) {
            clearTable();
            const layoutData = JSON.parse(localStorage.getItem(`layout_${layoutName}`));

            layoutData.cards.forEach(cardData => {
                const event = { clientX: 0, clientY: 0 }; // Placeholder event object
                createCard(event, cardData.type);
                const newCard = cards[cards.length - 1];
                newCard.style.left = cardData.left;
                newCard.style.top = cardData.top;
                newCard.dataset.model = cardData.model;
                newCard.dataset.prompt = cardData.prompt;
                const messageArea = newCard.querySelector('.message-area');
                if (messageArea) {
                    messageArea.value = cardData.message;
                }
            });

            layoutData.connections.forEach(connData => {
                const fromCard = cards[connData.from.cardIndex];
                const toCard = cards[connData.to.cardIndex];
                const fromPoint = fromCard.querySelector(`.${connData.from.pointClass}`);
                const toPoint = toCard.querySelector(`.${connData.to.pointClass}`);

                connections.push({
                    from: fromPoint,
                    to: toPoint
                });
            });

            drawConnections();
        }

        function deleteLayout(layoutName) {
            localStorage.removeItem(`layout_${layoutName}`);
            loadLayoutsFromCookies();
        }

        function setCookie(name, value, days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = `expires=${date.toUTCString()}`;
            document.cookie = `${name}=${value};${expires};path=/`;
        }

        function getCookie(name) {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.indexOf(`${name}=`) === 0) {
                    return cookie.substring(name.length + 1, cookie.length);
                }
            }
            return '';
        }

        initialize();
    </script>
</body>

</html>
